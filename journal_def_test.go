package main

import (
	"encoding/hex"
	"testing"

	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
)

func TestLe32(t *testing.T) {
	testCases := []struct {
		name     string
		data     [4]byte
		expected uint32
	}{
		{
			name:     "0x00000000",
			data:     [4]byte{0, 0, 0, 0},
			expected: 0x00000000,
		},
		{
			name:     "0x00000001",
			data:     [4]byte{1, 0, 0, 0},
			expected: 0x00000001,
		},
		{
			name:     "0x01000000",
			data:     [4]byte{0, 0, 0, 1},
			expected: 0x01000000,
		},
		{
			name:     "0x01020304",
			data:     [4]byte{4, 3, 2, 1},
			expected: 0x01020304,
		},
		{
			name:     "0xfffefdfc",
			data:     [4]byte{252, 253, 254, 255},
			expected: 0xfffefdfc,
		},
		{
			name:     "0xffffffff",
			data:     [4]byte{255, 255, 255, 255},
			expected: 0xffffffff,
		},
	}

	for _, tt := range testCases {
		t.Run(tt.name, func(t *testing.T) {
			assert.Equal(t, tt.expected, le32(tt.data))
		})
	}
}

func TestLe64(t *testing.T) {
	testCases := []struct {
		name     string
		data     [8]byte
		expected uint64
	}{
		{
			name:     "0x0000000000000000",
			data:     [8]byte{0, 0, 0, 0, 0, 0, 0, 0},
			expected: 0x0000000000000000,
		},
		{
			name:     "0x0000000000000001",
			data:     [8]byte{1, 0, 0, 0, 0, 0, 0, 0},
			expected: 0x0000000000000001,
		},
		{
			name:     "0x0100000000000000",
			data:     [8]byte{0, 0, 0, 0, 0, 0, 0, 1},
			expected: 0x0100000000000000,
		},
		{
			name:     "0x0102030405060708",
			data:     [8]byte{8, 7, 6, 5, 4, 3, 2, 1},
			expected: 0x0102030405060708,
		},
		{
			name:     "0xfffefdfcfbfaf9f8",
			data:     [8]byte{248, 249, 250, 251, 252, 253, 254, 255},
			expected: 0xfffefdfcfbfaf9f8,
		},
		{
			name:     "0xffffffffffffffff",
			data:     [8]byte{255, 255, 255, 255, 255, 255, 255, 255},
			expected: 0xffffffffffffffff,
		},
	}

	for _, tt := range testCases {
		t.Run(tt.name, func(t *testing.T) {
			assert.Equal(t, tt.expected, le64(tt.data))
		})
	}
}

func TestNewHeader(t *testing.T) {
	testCases := []struct {
		name     string
		data     string
		expected *Header
	}{
		{
			name: "header 1",
			data: "4c504b5348485248000000000c000000010000000000000069e0bc24292040569344cea3ad97204cfef9c27f1bb74f5c81d1e799f5941e9c6b84ae3ed1114c0b900c8c464e64a01569e0bc24292040569344cea3ad97204c000100000000000000ff7f0000000000f01500000000000080e33800000000001001000000000000d014000000000000f0493b000000000032030000000000006c00000000000000421c0000000000000808000000000000180d3900000000002b2bc5f6c41606004f69b2ccd3160600c3dc2396040000005f01000000000000290000000000000000000000000000003c0100000000000000000000000000000100000000000000",
			expected: &Header{
				signature:               [8]uint8{0x4c, 0x50, 0x4b, 0x53, 0x48, 0x48, 0x52, 0x48},
				incompatible_flags:      HEADER_INCOMPATIBLE_KEYED_HASH | HEADER_INCOMPATIBLE_COMPRESSED_ZSTD,
				state:                   STATE_ONLINE,
				file_id:                 [16]uint8{0x69, 0xe0, 0xbc, 0x24, 0x29, 0x20, 0x40, 0x56, 0x93, 0x44, 0xce, 0xa3, 0xad, 0x97, 0x20, 0x4c},
				machine_id:              [16]uint8{0xfe, 0xf9, 0xc2, 0x7f, 0x1b, 0xb7, 0x4f, 0x5c, 0x81, 0xd1, 0xe7, 0x99, 0xf5, 0x94, 0x1e, 0x9c},
				tail_entry_boot_id:      [16]uint8{0x6b, 0x84, 0xae, 0x3e, 0xd1, 0x11, 0x4c, 0x0b, 0x90, 0x0c, 0x8c, 0x46, 0x4e, 0x64, 0xa0, 0x15},
				seqnum_id:               [16]uint8{0x69, 0xe0, 0xbc, 0x24, 0x29, 0x20, 0x40, 0x56, 0x93, 0x44, 0xce, 0xa3, 0xad, 0x97, 0x20, 0x4c},
				header_size:             256,
				arena_size:              8388352,
				data_hash_table_offset:  5616,
				data_hash_table_size:    3728256,
				field_hash_table_offset: 272,
				field_hash_table_size:   5328,
				tail_object_offset:      3885552,
				n_objects:               818,
				n_entries:               108,
				tail_entry_seqnum:       7234,
				head_entry_seqnum:       2056,
				entry_array_offset:      3738904,
				head_entry_realtime:     1713885069781803,
				tail_entry_realtime:     1713948788418895,
				tail_entry_monotonic:    19698801859,
				n_data:                  351,
				n_fields:                41,
				n_tags:                  0,
				n_entry_arrays:          316,
				data_hash_chain_depth:   0,
				field_hash_chain_depth:  1,
				tail_entry_array_offset: 0,
				tail_entry_offset:       0,
			},
		},
	}
	for _, tt := range testCases {
		t.Run(tt.name, func(t *testing.T) {
			data, err := hex.DecodeString(tt.data)
			require.NoError(t, err)
			header, err := newHeader(data)
			require.NoError(t, err)
			assert.Equal(t, tt.expected, header)
		})
	}
}

func TestIsCompact(t *testing.T) {
	testCases := []struct {
		name     string
		header   *Header
		expected bool
	}{
		{
			name: "compact",
			header: &Header{
				incompatible_flags: HEADER_INCOMPATIBLE_COMPACT,
			},
			expected: true,
		},
		{
			name: "not compact",
			header: &Header{
				incompatible_flags: 0,
			},
			expected: false,
		},
	}
	for _, tt := range testCases {
		t.Run(tt.name, func(t *testing.T) {
			assert.Equal(t, tt.expected, tt.header.isCompact())
		})
	}
}

func TestNewObjectHeader(t *testing.T) {
	testCases := []struct {
		name        string
		data        string
		expected    *ObjectHeader
		payloadSize int
	}{
		{
			name: "header 1",
			data: "01000000000000006b00000000000000",
			// payload:  "7eb877f5204c379c000000000000000088443b000000000058473b0000000000000000000000000001000000000000005f534f555243455f5245414c54494d455f54494d455354414d503d31373133393438373838343136313533",
			expected: &ObjectHeader{
				objectType: OBJECT_DATA,
				size:       107,
			},
			payloadSize: 91,
		},
	}
	for _, tt := range testCases {
		t.Run(tt.name, func(t *testing.T) {
			data, err := hex.DecodeString(tt.data)
			require.NoError(t, err)
			header, err := newObjectHeader(data)
			require.NoError(t, err)
			assert.Equal(t, tt.expected, header)
			assert.Equal(t, tt.payloadSize, header.payloadSize())
		})
	}
}

func TestSetPayload(t *testing.T) {
	testCases := []struct {
		name    string
		payload string
	}{
		{
			name:    "payload 1",
			payload: "7eb877f5204c379c000000000000000088443b000000000058473b0000000000000000000000000001000000000000005f534f555243455f5245414c54494d455f54494d455354414d503d31373133393438373838343136313533",
		},
	}
	for _, tt := range testCases {
		t.Run(tt.name, func(t *testing.T) {
			payload, err := hex.DecodeString(tt.payload)
			require.NoError(t, err)
			header := ObjectHeader{}
			header.setPayload(payload)
			assert.Equal(t, payload, header.payload)
		})
	}
}

func TestData(t *testing.T) {
	testCases := []struct {
		name     string
		payload  string
		expected *Data
	}{
		{
			name:    "payload 1",
			payload: "7eb877f5204c379c000000000000000088443b000000000058473b0000000000000000000000000001000000000000005f534f555243455f5245414c54494d455f54494d455354414d503d31373133393438373838343136313533",
			expected: &Data{
				ObjectHeader: &ObjectHeader{
					payload: []uint8{0x7e, 0xb8, 0x77, 0xf5, 0x20, 0x4c, 0x37, 0x9c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x88, 0x44, 0x3b, 0x00, 0x00, 0x00, 0x00, 0x00, 0x58, 0x47, 0x3b, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x5f, 0x53, 0x4f, 0x55, 0x52, 0x43, 0x45, 0x5f, 0x52, 0x45, 0x41, 0x4c, 0x54, 0x49, 0x4d, 0x45, 0x5f, 0x54, 0x49, 0x4d, 0x45, 0x53, 0x54, 0x41, 0x4d, 0x50, 0x3d, 0x31, 0x37, 0x31, 0x33, 0x39, 0x34, 0x38, 0x37, 0x38, 0x38, 0x34, 0x31, 0x36, 0x31, 0x35, 0x33},
				},
				hash:                       11256549498076772478,
				next_hash_offset:           0,
				next_field_offset:          3884168,
				entry_offset:               3884888,
				entry_array_offset:         0,
				n_entries:                  1,
				tail_entry_array_offset:    0,
				tail_entry_array_n_entries: 0,
				payload:                    []uint8{0x5f, 0x53, 0x4f, 0x55, 0x52, 0x43, 0x45, 0x5f, 0x52, 0x45, 0x41, 0x4c, 0x54, 0x49, 0x4d, 0x45, 0x5f, 0x54, 0x49, 0x4d, 0x45, 0x53, 0x54, 0x41, 0x4d, 0x50, 0x3d, 0x31, 0x37, 0x31, 0x33, 0x39, 0x34, 0x38, 0x37, 0x38, 0x38, 0x34, 0x31, 0x36, 0x31, 0x35, 0x33},
			},
		},
	}
	for _, tt := range testCases {
		t.Run(tt.name, func(t *testing.T) {
			payload, err := hex.DecodeString(tt.payload)
			require.NoError(t, err)
			header := ObjectHeader{}
			header.setPayload(payload)
			data := header.Data(false)
			assert.Equal(t, tt.expected, data)
		})
	}
}

func TestEntry(t *testing.T) {
	testCases := []struct {
		name     string
		payload  string
		expected *Entry
		compact  bool
	}{
		{
			name:    "payload 1",
			payload: "421c0000000000004f69b2ccd3160600c3dc2396040000006b84ae3ed1114c0b900c8c464e64a015ee160cfa12d480c970f938000000000076f9b8a8e378f70010ff3800000000001952153dfdc0a65e",
			expected: &Entry{
				ObjectHeader: &ObjectHeader{
					payload: []uint8{
						0x42, 0x1c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
						0x4f, 0x69, 0xb2, 0xcc, 0xd3, 0x16, 0x06, 0x00,
						0xc3, 0xdc, 0x23, 0x96, 0x04, 0x00, 0x00, 0x00,
						0x6b, 0x84, 0xae, 0x3e, 0xd1, 0x11, 0x4c, 0x0b,
						0x90, 0x0c, 0x8c, 0x46, 0x4e, 0x64, 0xa0, 0x15,
						0xee, 0x16, 0x0c, 0xfa, 0x12, 0xd4, 0x80, 0xc9,
						0x70, 0xf9, 0x38, 0x00, 0x00, 0x00, 0x00, 0x00,
						0x76, 0xf9, 0xb8, 0xa8, 0xe3, 0x78, 0xf7, 0x00,
						0x10, 0xff, 0x38, 0x00, 0x00, 0x00, 0x00, 0x00,
						0x19, 0x52, 0x15, 0x3d, 0xfd, 0xc0, 0xa6, 0x5e,
						// 0x40, 0x02, 0x39, 0x00, 0x00, 0x00, 0x00, 0x00, 0x2a, 0x41, 0x8a, 0xb8, 0x1f, 0x9b, 0xd7, 0xee, 0x60, 0x03, 0x39, 0x00, 0x00, 0x00, 0x00, 0x00, 0xd3, 0xcf, 0x1c, 0x80, 0xba, 0xbc, 0x1e, 0xce, 0xb0, 0x04, 0x39, 0x00, 0x00, 0x00, 0x00, 0x00, 0x23, 0xae, 0x0b, 0x4a, 0xe2, 0xfa, 0xf8, 0x56, 0x80, 0x06, 0x39, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x71, 0x62, 0x09, 0xa2, 0xf7, 0xe3, 0x09, 0x18, 0x07, 0x39, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc8, 0x5c, 0xa0, 0x2c, 0xce, 0x52, 0x6b, 0x65, 0x28, 0x09, 0x39, 0x00, 0x00, 0x00, 0x00, 0x00, 0x9b, 0x48, 0x63, 0x91, 0x10, 0x99, 0x89, 0x28, 0xc8, 0x09, 0x39, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc4, 0xa8, 0xba, 0xea, 0x92, 0x4f, 0x76, 0x5e, 0x60, 0x89, 0x39, 0x00, 0x00, 0x00, 0x00, 0x00, 0x34, 0xf8, 0x3c, 0xf9, 0xaf, 0xa9, 0xca, 0x2a, 0x08, 0x8a, 0x39, 0x00, 0x00, 0x00, 0x00, 0x00, 0xe4, 0x6b, 0xda, 0xf7, 0x64, 0x64, 0x27, 0xaa, 0x60, 0x8a, 0x39, 0x00, 0x00, 0x00, 0x00, 0x00, 0x43, 0xb9, 0x8e, 0xa8, 0x39, 0x8a, 0xae, 0xbb, 0x38, 0x8c, 0x39, 0x00, 0x00, 0x00, 0x00, 0x00, 0x90, 0x61, 0xba, 0x15, 0x57, 0x33, 0x07, 0xe8, 0x88, 0x8c, 0x39, 0x00, 0x00, 0x00, 0x00, 0x00, 0x44, 0x16, 0x66, 0x8a, 0xc2, 0x7c, 0xf5, 0xe5, 0x40, 0x8d, 0x39, 0x00, 0x00, 0x00, 0x00, 0x00, 0xe3, 0x22, 0x24, 0x27, 0x4c, 0xd9, 0x41, 0x49, 0xd0, 0x92, 0x39, 0x00, 0x00, 0x00, 0x00, 0x00, 0xa4, 0x9d, 0x5b, 0xc7, 0xa3, 0x59, 0xaf, 0xef, 0x10, 0xba, 0x39, 0x00, 0x00, 0x00, 0x00, 0x00, 0x8c, 0xbe, 0xca, 0x48, 0x2c, 0xb1, 0x1b, 0xe7, 0x60, 0x37, 0x3b, 0x00, 0x00, 0x00, 0x00, 0x00, 0xa9, 0x76, 0x5f, 0x50, 0x0c, 0x0a, 0x32, 0x53, 0xb8, 0x37, 0x3b, 0x00, 0x00, 0x00, 0x00, 0x00, 0xb5, 0xa3, 0xac, 0xdf, 0x1d, 0x3f, 0x75, 0x62, 0x38, 0x38, 0x3b, 0x00, 0x00, 0x00, 0x00, 0x00, 0x17, 0xab, 0x60, 0x0b, 0xde, 0xa7, 0x95, 0x7e, 0x90, 0x38, 0x3b, 0x00, 0x00, 0x00, 0x00, 0x00, 0x39, 0x9c, 0x9f, 0xb7, 0x32, 0xaa, 0x47, 0xef, 0xf0, 0x38, 0x3b, 0x00, 0x00, 0x00, 0x00, 0x00, 0x56, 0xa0, 0x65, 0x9f, 0x6c, 0x6a, 0x10, 0xa1, 0xc8, 0x3b, 0x3b, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0a, 0x22, 0xf1, 0xf3, 0x37, 0xf4, 0xe0, 0xad, 0xe0, 0x42, 0x3b, 0x00, 0x00, 0x00, 0x00, 0x00, 0x97, 0xac, 0x76, 0x37, 0xfa, 0xc8, 0x17, 0x09, 0xe0, 0x43, 0x3b, 0x00, 0x00, 0x00, 0x00, 0x00, 0xd7, 0xb3, 0xdb, 0x82, 0x6a, 0x61, 0xba, 0x9b, 0x30, 0x44, 0x3b, 0x00, 0x00, 0x00, 0x00, 0x00, 0x17, 0xdd, 0xcd, 0x9c, 0x02, 0x33, 0x99, 0xb3, 0xe8, 0x46, 0x3b, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7e, 0xb8, 0x77, 0xf5, 0x20, 0x4c, 0x37, 0x9c,
					},
				},
				seqnum:    7234,
				realtime:  1713948788418895,
				monotonic: 19698801859,
				boot_id:   [16]uint8{0x6b, 0x84, 0xae, 0x3e, 0xd1, 0x11, 0x4c, 0x0b, 0x90, 0x0c, 0x8c, 0x46, 0x4e, 0x64, 0xa0, 0x15},
				xor_hash:  14519838376612075246,
				itemsRegular: []regularEntryItem{
					{
						object_offset: 3733872,
						hash:          69657238431136118,
					},
					{
						object_offset: 3735312,
						hash:          6820350879583261209,
					},
				},
				itemsCompact: []compactEntryItem{},
			},
			compact: false,
		},
	}
	for _, tt := range testCases {
		t.Run(tt.name, func(t *testing.T) {
			payload, err := hex.DecodeString(tt.payload)
			require.NoError(t, err)
			header := ObjectHeader{}
			header.setPayload(payload)
			entry := header.Entry(tt.compact)
			assert.Equal(t, tt.expected, entry)
		})
	}
}

func TestEntryArray(t *testing.T) {
	testCases := []struct {
		name     string
		payload  string
		expected *EntryArray
		compact  bool
	}{
		{
			name:    "payload 1",
			payload: "0000000000000000c8e2390000000000b0e7390000000000f0fe390000000000a0013a000000000020053a0000000000b8073a0000000000680a3a0000000000c80c3a0000000000b80f3a000000000068123a0000000000c8143a000000000060173a0000000000101a3a0000000000701c3a000000000090213a000000000040243a000000000088273a0000000000202a3a0000000000d02c3a0000000000b8423a000000000038463a0000000000d0493a0000000000d8583a0000000000705b3a0000000000205e3a000000000080603a0000000000a0643a0000000000d86d3a0000000000c0703a000000000098743a0000000000a07b3a0000000000f07f3a0000000000f8833a0000000000f8873a0000000000808e3a0000000000d8923a000000000040973a0000000000f09a3a0000000000289f3a000000000058a33a000000000078a73a000000000098ab3a0000000000a8af3a0000000000b0b43a0000000000a8b93a000000000080be3a0000000000f0c23a000000000058c73a0000000000f8cb3a0000000000a8cf3a0000000000c0db3a000000000050f13a000000000028f53a000000000028f93a000000000030013b0000000000d0043b0000000000a8083b000000000018143b0000000000f0173b0000000000c81b3b0000000000281f3b000000000000233b0000000000782a3b0000000000502e3b000000000070323b0000000000d8393b0000000000d03c3b0000000000f0403b0000000000f8443b000000000058473b000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
			expected: &EntryArray{
				ObjectHeader: &ObjectHeader{
					payload: []uint8{
						0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
						0xc8, 0xe2, 0x39, 0x00, 0x00, 0x00, 0x00, 0x00,
						0xb0, 0xe7, 0x39, 0x00, 0x00, 0x00, 0x00, 0x00,
						0xf0, 0xfe, 0x39, 0x00, 0x00, 0x00, 0x00, 0x00,
						0xa0, 0x01, 0x3a, 0x00, 0x00, 0x00, 0x00, 0x00,
						0x20, 0x05, 0x3a, 0x00, 0x00, 0x00, 0x00, 0x00,
						0xb8, 0x07, 0x3a, 0x00, 0x00, 0x00, 0x00, 0x00,
						0x68, 0x0a, 0x3a, 0x00, 0x00, 0x00, 0x00, 0x00,
						0xc8, 0x0c, 0x3a, 0x00, 0x00, 0x00, 0x00, 0x00,
						0xb8, 0x0f, 0x3a, 0x00, 0x00, 0x00, 0x00, 0x00,
						0x68, 0x12, 0x3a, 0x00, 0x00, 0x00, 0x00, 0x00,
						0xc8, 0x14, 0x3a, 0x00, 0x00, 0x00, 0x00, 0x00,
						0x60, 0x17, 0x3a, 0x00, 0x00, 0x00, 0x00, 0x00,
						0x10, 0x1a, 0x3a, 0x00, 0x00, 0x00, 0x00, 0x00,
						0x70, 0x1c, 0x3a, 0x00, 0x00, 0x00, 0x00, 0x00,
						0x90, 0x21, 0x3a, 0x00, 0x00, 0x00, 0x00, 0x00,
						0x40, 0x24, 0x3a, 0x00, 0x00, 0x00, 0x00, 0x00,
						0x88, 0x27, 0x3a, 0x00, 0x00, 0x00, 0x00, 0x00,
						0x20, 0x2a, 0x3a, 0x00, 0x00, 0x00, 0x00, 0x00,
						0xd0, 0x2c, 0x3a, 0x00, 0x00, 0x00, 0x00, 0x00,
						0xb8, 0x42, 0x3a, 0x00, 0x00, 0x00, 0x00, 0x00,
						0x38, 0x46, 0x3a, 0x00, 0x00, 0x00, 0x00, 0x00,
						0xd0, 0x49, 0x3a, 0x00, 0x00, 0x00, 0x00, 0x00,
						0xd8, 0x58, 0x3a, 0x00, 0x00, 0x00, 0x00, 0x00,
						0x70, 0x5b, 0x3a, 0x00, 0x00, 0x00, 0x00, 0x00,
						0x20, 0x5e, 0x3a, 0x00, 0x00, 0x00, 0x00, 0x00,
						0x80, 0x60, 0x3a, 0x00, 0x00, 0x00, 0x00, 0x00,
						0xa0, 0x64, 0x3a, 0x00, 0x00, 0x00, 0x00, 0x00,
						0xd8, 0x6d, 0x3a, 0x00, 0x00, 0x00, 0x00, 0x00,
						0xc0, 0x70, 0x3a, 0x00, 0x00, 0x00, 0x00, 0x00,
						0x98, 0x74, 0x3a, 0x00, 0x00, 0x00, 0x00, 0x00,
						0xa0, 0x7b, 0x3a, 0x00, 0x00, 0x00, 0x00, 0x00,
						0xf0, 0x7f, 0x3a, 0x00, 0x00, 0x00, 0x00, 0x00,
						0xf8, 0x83, 0x3a, 0x00, 0x00, 0x00, 0x00, 0x00,
						0xf8, 0x87, 0x3a, 0x00, 0x00, 0x00, 0x00, 0x00,
						0x80, 0x8e, 0x3a, 0x00, 0x00, 0x00, 0x00, 0x00,
						0xd8, 0x92, 0x3a, 0x00, 0x00, 0x00, 0x00, 0x00,
						0x40, 0x97, 0x3a, 0x00, 0x00, 0x00, 0x00, 0x00,
						0xf0, 0x9a, 0x3a, 0x00, 0x00, 0x00, 0x00, 0x00,
						0x28, 0x9f, 0x3a, 0x00, 0x00, 0x00, 0x00, 0x00,
						0x58, 0xa3, 0x3a, 0x00, 0x00, 0x00, 0x00, 0x00,
						0x78, 0xa7, 0x3a, 0x00, 0x00, 0x00, 0x00, 0x00,
						0x98, 0xab, 0x3a, 0x00, 0x00, 0x00, 0x00, 0x00,
						0xa8, 0xaf, 0x3a, 0x00, 0x00, 0x00, 0x00, 0x00,
						0xb0, 0xb4, 0x3a, 0x00, 0x00, 0x00, 0x00, 0x00,
						0xa8, 0xb9, 0x3a, 0x00, 0x00, 0x00, 0x00, 0x00,
						0x80, 0xbe, 0x3a, 0x00, 0x00, 0x00, 0x00, 0x00,
						0xf0, 0xc2, 0x3a, 0x00, 0x00, 0x00, 0x00, 0x00,
						0x58, 0xc7, 0x3a, 0x00, 0x00, 0x00, 0x00, 0x00,
						0xf8, 0xcb, 0x3a, 0x00, 0x00, 0x00, 0x00, 0x00,
						0xa8, 0xcf, 0x3a, 0x00, 0x00, 0x00, 0x00, 0x00,
						0xc0, 0xdb, 0x3a, 0x00, 0x00, 0x00, 0x00, 0x00,
						0x50, 0xf1, 0x3a, 0x00, 0x00, 0x00, 0x00, 0x00,
						0x28, 0xf5, 0x3a, 0x00, 0x00, 0x00, 0x00, 0x00,
						0x28, 0xf9, 0x3a, 0x00, 0x00, 0x00, 0x00, 0x00,
						0x30, 0x01, 0x3b, 0x00, 0x00, 0x00, 0x00, 0x00,
						0xd0, 0x04, 0x3b, 0x00, 0x00, 0x00, 0x00, 0x00,
						0xa8, 0x08, 0x3b, 0x00, 0x00, 0x00, 0x00, 0x00,
						0x18, 0x14, 0x3b, 0x00, 0x00, 0x00, 0x00, 0x00,
						0xf0, 0x17, 0x3b, 0x00, 0x00, 0x00, 0x00, 0x00,
						0xc8, 0x1b, 0x3b, 0x00, 0x00, 0x00, 0x00, 0x00,
						0x28, 0x1f, 0x3b, 0x00, 0x00, 0x00, 0x00, 0x00,
						0x00, 0x23, 0x3b, 0x00, 0x00, 0x00, 0x00, 0x00,
						0x78, 0x2a, 0x3b, 0x00, 0x00, 0x00, 0x00, 0x00,
						0x50, 0x2e, 0x3b, 0x00, 0x00, 0x00, 0x00, 0x00,
						0x70, 0x32, 0x3b, 0x00, 0x00, 0x00, 0x00, 0x00,
						0xd8, 0x39, 0x3b, 0x00, 0x00, 0x00, 0x00, 0x00,
						0xd0, 0x3c, 0x3b, 0x00, 0x00, 0x00, 0x00, 0x00,
						0xf0, 0x40, 0x3b, 0x00, 0x00, 0x00, 0x00, 0x00,
						0xf8, 0x44, 0x3b, 0x00, 0x00, 0x00, 0x00, 0x00,
						0x58, 0x47, 0x3b, 0x00, 0x00, 0x00, 0x00, 0x00,
						0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
						0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
						0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
						0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
						0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
						0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
						0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
						0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					},
				},
				regularItems: []uint64{
					3793608,
					3794864,
					3800816,
					3801504,
					3802400,
					3803064,
					3803752,
					3804360,
					3805112,
					3805800,
					3806408,
					3807072,
					3807760,
					3808368,
					3809680,
					3810368,
					3811208,
					3811872,
					3812560,
					3818168,
					3819064,
					3819984,
					3823832,
					3824496,
					3825184,
					3825792,
					3826848,
					3829208,
					3829952,
					3830936,
					3832736,
					3833840,
					3834872,
					3835896,
					3837568,
					3838680,
					3839808,
					3840752,
					3841832,
					3842904,
					3843960,
					3845016,
					3846056,
					3847344,
					3848616,
					3849856,
					3850992,
					3852120,
					3853304,
					3854248,
					3857344,
					3862864,
					3863848,
					3864872,
					3866928,
					3867856,
					3868840,
					3871768,
					3872752,
					3873736,
					3874600,
					3875584,
					3877496,
					3878480,
					3879536,
					3881432,
					3882192,
					3883248,
					3884280,
					3884888,
					0,
					0,
					0,
					0,
					0,
					0,
					0,
					0,
				},
				compactItems: []uint32{},
				countItems:   78,
			},
			compact: false,
		},
	}
	for _, tt := range testCases {
		t.Run(tt.name, func(t *testing.T) {
			payload, err := hex.DecodeString(tt.payload)
			require.NoError(t, err)
			header := ObjectHeader{}
			header.setPayload(payload)
			entry := header.EntryArray(tt.compact)
			assert.Equal(t, tt.expected, entry)
		})
	}
}
